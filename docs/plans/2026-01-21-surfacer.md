# Surfacer Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a single-file web app that generates surfacing GCode for a Shapeoko 5 CNC.

**Architecture:** Vanilla TypeScript web app bundled to single HTML file via Vite. Form inputs drive a toolpath calculator that generates GRBL GCode. Live SVG preview shows the raster pattern.

**Tech Stack:** Bun, Vite, TypeScript, vite-plugin-singlefile

---

### Task 1: Project Setup

**Files:**
- Create: `package.json`
- Create: `tsconfig.json`
- Create: `vite.config.ts`
- Create: `index.html`
- Create: `src/main.ts`

**Step 1: Initialize project with Bun**

Run: `bun init -y`
Expected: Creates package.json

**Step 2: Install dependencies**

Run: `bun add -d vite vite-plugin-singlefile typescript`
Expected: Dependencies added to package.json

**Step 3: Create tsconfig.json**

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "noEmit": true,
    "isolatedModules": true,
    "skipLibCheck": true
  },
  "include": ["src"]
}
```

**Step 4: Create vite.config.ts**

```typescript
import { defineConfig } from 'vite'
import { viteSingleFile } from 'vite-plugin-singlefile'

export default defineConfig({
  plugins: [viteSingleFile()],
  build: {
    outDir: 'dist',
  },
})
```

**Step 5: Create index.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Surfacer</title>
</head>
<body>
  <div id="app"></div>
  <script type="module" src="/src/main.ts"></script>
</body>
</html>
```

**Step 6: Create src/main.ts**

```typescript
document.querySelector<HTMLDivElement>('#app')!.innerHTML = '<h1>Surfacer</h1>'
```

**Step 7: Add scripts to package.json**

Add to package.json:
```json
{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "test": "bun test"
  }
}
```

**Step 8: Verify dev server works**

Run: `bun run dev`
Expected: Server starts, browser shows "Surfacer" heading

**Step 9: Verify build works**

Run: `bun run build`
Expected: Creates dist/index.html as single file

**Step 10: Commit**

```bash
git init
git add .
git commit -m "chore: initial project setup with Bun, Vite, TypeScript"
```

---

### Task 2: Parameter Types and Defaults

**Files:**
- Create: `src/types.ts`
- Create: `src/defaults.ts`
- Create: `src/types.test.ts`

**Step 1: Write the test for defaults**

```typescript
// src/types.test.ts
import { describe, expect, test } from 'bun:test'
import { DEFAULT_PARAMS } from './defaults'

describe('DEFAULT_PARAMS', () => {
  test('has correct default values', () => {
    expect(DEFAULT_PARAMS.bitDiameter).toBe(1.25)
    expect(DEFAULT_PARAMS.stepoverPercent).toBe(50)
    expect(DEFAULT_PARAMS.rasterDirection).toBe('x')
    expect(DEFAULT_PARAMS.skimPass).toBe(false)
    expect(DEFAULT_PARAMS.numPasses).toBe(1)
    expect(DEFAULT_PARAMS.depthPerPass).toBe(0.01)
    expect(DEFAULT_PARAMS.pauseBetweenPasses).toBe(false)
    expect(DEFAULT_PARAMS.pauseInterval).toBe(1)
    expect(DEFAULT_PARAMS.feedRate).toBe(125)
    expect(DEFAULT_PARAMS.plungeRate).toBe(12)
    expect(DEFAULT_PARAMS.spindleRpm).toBe(18000)
    expect(DEFAULT_PARAMS.safeZ).toBe(0.125)
    expect(DEFAULT_PARAMS.overhangMode).toBe('full')
  })
})
```

**Step 2: Run test to verify it fails**

Run: `bun test`
Expected: FAIL with "Cannot find module './defaults'"

**Step 3: Create types.ts**

```typescript
// src/types.ts
export interface SurfacingParams {
  // Stock dimensions (required, no defaults)
  stockWidth: number
  stockHeight: number

  // Tool settings
  bitDiameter: number
  stepoverPercent: number
  overhangMode: 'full' | 'custom'
  customOverhang: number

  // Toolpath settings
  rasterDirection: 'x' | 'y'
  skimPass: boolean
  numPasses: number
  depthPerPass: number
  pauseBetweenPasses: boolean
  pauseInterval: number

  // Speeds and feeds
  feedRate: number
  plungeRate: number
  spindleRpm: number
  safeZ: number
}

export type PartialParams = Partial<SurfacingParams> & {
  stockWidth: number
  stockHeight: number
}
```

**Step 4: Create defaults.ts**

```typescript
// src/defaults.ts
import type { SurfacingParams } from './types'

export const DEFAULT_PARAMS: Omit<SurfacingParams, 'stockWidth' | 'stockHeight'> = {
  bitDiameter: 1.25,
  stepoverPercent: 50,
  overhangMode: 'full',
  customOverhang: 0,
  rasterDirection: 'x',
  skimPass: false,
  numPasses: 1,
  depthPerPass: 0.01,
  pauseBetweenPasses: false,
  pauseInterval: 1,
  feedRate: 125,
  plungeRate: 12,
  spindleRpm: 18000,
  safeZ: 0.125,
}

export function mergeWithDefaults(partial: { stockWidth: number; stockHeight: number } & Partial<SurfacingParams>): SurfacingParams {
  return {
    ...DEFAULT_PARAMS,
    ...partial,
  }
}
```

**Step 5: Run test to verify it passes**

Run: `bun test`
Expected: PASS

**Step 6: Commit**

```bash
git add .
git commit -m "feat: add parameter types and defaults"
```

---

### Task 3: Toolpath Calculation - Basic Raster

**Files:**
- Create: `src/toolpath.ts`
- Create: `src/toolpath.test.ts`

**Step 1: Write test for basic raster calculation**

```typescript
// src/toolpath.test.ts
import { describe, expect, test } from 'bun:test'
import { calculateToolpath } from './toolpath'
import { mergeWithDefaults } from './defaults'

describe('calculateToolpath', () => {
  test('calculates correct number of passes for X-axis raster', () => {
    const params = mergeWithDefaults({
      stockWidth: 10,
      stockHeight: 5,
      bitDiameter: 1,
      stepoverPercent: 50,
      overhangMode: 'full',
      numPasses: 1,
      depthPerPass: 0.01,
      skimPass: false,
    })

    const toolpath = calculateToolpath(params)

    // Stepover = 1 * 0.5 = 0.5"
    // Y range = -1 (overhang) to 5+1 (stock + overhang) = 6" total + overhang
    // With full overhang (1"), Y goes from -1 to 6
    // Number of Y passes = ceil(7 / 0.5) + 1 = 15 passes
    expect(toolpath.passes.length).toBe(1) // 1 Z pass
    expect(toolpath.passes[0].lines.length).toBeGreaterThan(0)
  })

  test('calculates correct overhang for full mode', () => {
    const params = mergeWithDefaults({
      stockWidth: 10,
      stockHeight: 5,
      bitDiameter: 2,
      overhangMode: 'full',
    })

    const toolpath = calculateToolpath(params)

    // Full overhang = bit diameter = 2"
    // X range: -2 to 10+2 = 12" total travel
    expect(toolpath.bounds.xMin).toBe(-2)
    expect(toolpath.bounds.xMax).toBe(12)
    expect(toolpath.bounds.yMin).toBe(-2)
    expect(toolpath.bounds.yMax).toBe(7)
  })

  test('uses custom overhang when specified', () => {
    const params = mergeWithDefaults({
      stockWidth: 10,
      stockHeight: 5,
      bitDiameter: 2,
      overhangMode: 'custom',
      customOverhang: 0.5,
    })

    const toolpath = calculateToolpath(params)

    expect(toolpath.bounds.xMin).toBe(-0.5)
    expect(toolpath.bounds.xMax).toBe(10.5)
  })
})
```

**Step 2: Run test to verify it fails**

Run: `bun test`
Expected: FAIL with "Cannot find module './toolpath'"

**Step 3: Write minimal toolpath implementation**

```typescript
// src/toolpath.ts
import type { SurfacingParams } from './types'

export interface RasterLine {
  y: number
  xStart: number
  xEnd: number
  direction: 'positive' | 'negative'
}

export interface ZPass {
  z: number
  lines: RasterLine[]
  pauseAfter: boolean
}

export interface Toolpath {
  passes: ZPass[]
  bounds: {
    xMin: number
    xMax: number
    yMin: number
    yMax: number
  }
  params: SurfacingParams
}

export function calculateToolpath(params: SurfacingParams): Toolpath {
  const overhang = params.overhangMode === 'full'
    ? params.bitDiameter
    : params.customOverhang

  const stepover = params.bitDiameter * (params.stepoverPercent / 100)

  // Calculate bounds with overhang
  const xMin = -overhang
  const xMax = params.stockWidth + overhang
  const yMin = -overhang
  const yMax = params.stockHeight + overhang

  // Calculate Y positions for raster lines (X-axis raster means lines run along X)
  const yPositions: number[] = []
  let y = yMin
  while (y <= yMax) {
    yPositions.push(y)
    y += stepover
  }
  // Ensure we cover the full height
  if (yPositions[yPositions.length - 1] < yMax) {
    yPositions.push(yMax)
  }

  // Generate Z passes
  const passes: ZPass[] = []
  const totalPasses = params.numPasses + (params.skimPass ? 1 : 0)

  for (let i = 0; i < totalPasses; i++) {
    const isSkimPass = params.skimPass && i === 0
    const adjustedIndex = params.skimPass ? i : i + 1
    const z = isSkimPass ? 0 : -(adjustedIndex * params.depthPerPass)

    const lines: RasterLine[] = yPositions.map((yPos, lineIndex) => ({
      y: yPos,
      xStart: lineIndex % 2 === 0 ? xMin : xMax,
      xEnd: lineIndex % 2 === 0 ? xMax : xMin,
      direction: (lineIndex % 2 === 0 ? 'positive' : 'negative') as 'positive' | 'negative',
    }))

    const shouldPause = params.pauseBetweenPasses &&
      (i + 1) % params.pauseInterval === 0 &&
      i < totalPasses - 1 // Don't pause after last pass

    passes.push({ z, lines, pauseAfter: shouldPause })
  }

  return {
    passes,
    bounds: { xMin, xMax, yMin, yMax },
    params,
  }
}
```

**Step 4: Run test to verify it passes**

Run: `bun test`
Expected: PASS

**Step 5: Commit**

```bash
git add .
git commit -m "feat: add toolpath calculation with raster pattern"
```

---

### Task 4: Toolpath - Skim Pass and Multi-Pass

**Files:**
- Modify: `src/toolpath.test.ts`

**Step 1: Write test for skim pass**

Add to `src/toolpath.test.ts`:

```typescript
describe('skim pass', () => {
  test('adds Z=0 pass when skimPass is true', () => {
    const params = mergeWithDefaults({
      stockWidth: 10,
      stockHeight: 5,
      skimPass: true,
      numPasses: 2,
      depthPerPass: 0.01,
    })

    const toolpath = calculateToolpath(params)

    expect(toolpath.passes.length).toBe(3) // skim + 2 regular
    expect(toolpath.passes[0].z).toBe(0)
    expect(toolpath.passes[1].z).toBe(-0.01)
    expect(toolpath.passes[2].z).toBe(-0.02)
  })

  test('does not add skim pass when skimPass is false', () => {
    const params = mergeWithDefaults({
      stockWidth: 10,
      stockHeight: 5,
      skimPass: false,
      numPasses: 2,
      depthPerPass: 0.01,
    })

    const toolpath = calculateToolpath(params)

    expect(toolpath.passes.length).toBe(2)
    expect(toolpath.passes[0].z).toBe(-0.01)
    expect(toolpath.passes[1].z).toBe(-0.02)
  })
})
```

**Step 2: Run test to verify it passes**

Run: `bun test`
Expected: PASS (already implemented in Task 3)

**Step 3: Write test for pause intervals**

Add to `src/toolpath.test.ts`:

```typescript
describe('pause intervals', () => {
  test('pauses after every N passes when enabled', () => {
    const params = mergeWithDefaults({
      stockWidth: 10,
      stockHeight: 5,
      numPasses: 6,
      pauseBetweenPasses: true,
      pauseInterval: 2,
    })

    const toolpath = calculateToolpath(params)

    expect(toolpath.passes[0].pauseAfter).toBe(false) // pass 1
    expect(toolpath.passes[1].pauseAfter).toBe(true)  // pass 2 - pause
    expect(toolpath.passes[2].pauseAfter).toBe(false) // pass 3
    expect(toolpath.passes[3].pauseAfter).toBe(true)  // pass 4 - pause
    expect(toolpath.passes[4].pauseAfter).toBe(false) // pass 5
    expect(toolpath.passes[5].pauseAfter).toBe(false) // pass 6 - last, no pause
  })

  test('does not pause when disabled', () => {
    const params = mergeWithDefaults({
      stockWidth: 10,
      stockHeight: 5,
      numPasses: 3,
      pauseBetweenPasses: false,
    })

    const toolpath = calculateToolpath(params)

    expect(toolpath.passes.every(p => !p.pauseAfter)).toBe(true)
  })
})
```

**Step 4: Run test to verify it passes**

Run: `bun test`
Expected: PASS (already implemented in Task 3)

**Step 5: Commit**

```bash
git add .
git commit -m "test: add tests for skim pass and pause intervals"
```

---

### Task 5: GCode Generation

**Files:**
- Create: `src/gcode.ts`
- Create: `src/gcode.test.ts`

**Step 1: Write test for GCode preamble**

```typescript
// src/gcode.test.ts
import { describe, expect, test } from 'bun:test'
import { generateGCode } from './gcode'
import { calculateToolpath } from './toolpath'
import { mergeWithDefaults } from './defaults'

describe('generateGCode', () => {
  test('generates correct preamble', () => {
    const params = mergeWithDefaults({
      stockWidth: 10,
      stockHeight: 5,
      spindleRpm: 18000,
    })
    const toolpath = calculateToolpath(params)
    const gcode = generateGCode(toolpath)

    expect(gcode).toContain('G90')
    expect(gcode).toContain('G20')
    expect(gcode).toContain('M3 S18000')
  })

  test('generates correct postamble', () => {
    const params = mergeWithDefaults({
      stockWidth: 10,
      stockHeight: 5,
      safeZ: 0.125,
    })
    const toolpath = calculateToolpath(params)
    const gcode = generateGCode(toolpath)

    expect(gcode).toContain('M5')
    expect(gcode).toContain('M30')
  })

  test('inserts M0 for pause', () => {
    const params = mergeWithDefaults({
      stockWidth: 10,
      stockHeight: 5,
      numPasses: 2,
      pauseBetweenPasses: true,
      pauseInterval: 1,
    })
    const toolpath = calculateToolpath(params)
    const gcode = generateGCode(toolpath)

    // Should have M0 after first pass but not after second (last)
    const m0Count = (gcode.match(/M0\b/g) || []).length
    expect(m0Count).toBe(1)
  })

  test('uses correct feed rates', () => {
    const params = mergeWithDefaults({
      stockWidth: 10,
      stockHeight: 5,
      feedRate: 125,
      plungeRate: 12,
    })
    const toolpath = calculateToolpath(params)
    const gcode = generateGCode(toolpath)

    expect(gcode).toContain('F125')
    expect(gcode).toContain('F12')
  })
})
```

**Step 2: Run test to verify it fails**

Run: `bun test`
Expected: FAIL with "Cannot find module './gcode'"

**Step 3: Write GCode generator**

```typescript
// src/gcode.ts
import type { Toolpath, ZPass, RasterLine } from './toolpath'

export function generateGCode(toolpath: Toolpath): string {
  const { params } = toolpath
  const lines: string[] = []

  // Preamble
  lines.push('; Surfacing operation')
  lines.push(`; Stock: ${params.stockWidth}" x ${params.stockHeight}"`)
  lines.push(`; Bit: ${params.bitDiameter}" fly cutter`)
  lines.push(`; Stepover: ${params.stepoverPercent}%`)
  lines.push('')
  lines.push('G90 ; Absolute positioning')
  lines.push('G20 ; Inches')
  lines.push(`M3 S${params.spindleRpm} ; Spindle on`)
  lines.push(`G0 Z${fmt(params.safeZ)} ; Retract to safe Z`)

  // Move to start position
  const startX = toolpath.passes[0]?.lines[0]?.xStart ?? toolpath.bounds.xMin
  const startY = toolpath.passes[0]?.lines[0]?.y ?? toolpath.bounds.yMin
  lines.push(`G0 X${fmt(startX)} Y${fmt(startY)} ; Move to start`)
  lines.push('')

  // Generate passes
  toolpath.passes.forEach((pass, passIndex) => {
    lines.push(`; Pass ${passIndex + 1} at Z=${fmt(pass.z)}`)
    lines.push(...generatePass(pass, params.safeZ, params.feedRate, params.plungeRate))

    if (pass.pauseAfter) {
      lines.push('M0 ; Pause - press resume to continue or stop to end')
    }
    lines.push('')
  })

  // Postamble
  lines.push(`G0 Z${fmt(params.safeZ)} ; Final retract`)
  lines.push('M5 ; Spindle off')
  lines.push('M30 ; Program end')

  return lines.join('\n')
}

function generatePass(pass: ZPass, safeZ: number, feedRate: number, plungeRate: number): string[] {
  const lines: string[] = []

  pass.lines.forEach((line, lineIndex) => {
    if (lineIndex === 0) {
      // First line of pass - plunge to Z
      lines.push(`G1 Z${fmt(pass.z)} F${plungeRate} ; Plunge`)
    } else {
      // Move to start of next line
      lines.push(`G0 Z${fmt(safeZ)} ; Retract`)
      lines.push(`G0 Y${fmt(line.y)} ; Stepover`)
      lines.push(`G1 Z${fmt(pass.z)} F${plungeRate} ; Plunge`)
    }

    // Cut across
    lines.push(`G1 X${fmt(line.xEnd)} F${feedRate} ; Cut`)
  })

  lines.push(`G0 Z${fmt(safeZ)} ; Retract after pass`)

  return lines
}

function fmt(n: number): string {
  // Format number to 4 decimal places, removing trailing zeros
  return n.toFixed(4).replace(/\.?0+$/, '')
}
```

**Step 4: Run test to verify it passes**

Run: `bun test`
Expected: PASS

**Step 5: Commit**

```bash
git add .
git commit -m "feat: add GCode generation"
```

---

### Task 6: SVG Preview Rendering

**Files:**
- Create: `src/preview.ts`
- Create: `src/preview.test.ts`

**Step 1: Write test for preview bounds**

```typescript
// src/preview.test.ts
import { describe, expect, test } from 'bun:test'
import { generatePreviewSVG } from './preview'
import { calculateToolpath } from './toolpath'
import { mergeWithDefaults } from './defaults'

describe('generatePreviewSVG', () => {
  test('generates valid SVG', () => {
    const params = mergeWithDefaults({
      stockWidth: 10,
      stockHeight: 5,
    })
    const toolpath = calculateToolpath(params)
    const svg = generatePreviewSVG(toolpath, 400, 300)

    expect(svg).toContain('<svg')
    expect(svg).toContain('</svg>')
  })

  test('includes stock rectangle', () => {
    const params = mergeWithDefaults({
      stockWidth: 10,
      stockHeight: 5,
    })
    const toolpath = calculateToolpath(params)
    const svg = generatePreviewSVG(toolpath, 400, 300)

    expect(svg).toContain('class="stock"')
    expect(svg).toContain('<rect')
  })

  test('includes raster lines', () => {
    const params = mergeWithDefaults({
      stockWidth: 10,
      stockHeight: 5,
    })
    const toolpath = calculateToolpath(params)
    const svg = generatePreviewSVG(toolpath, 400, 300)

    expect(svg).toContain('<line')
    expect(svg).toContain('class="raster"')
  })
})
```

**Step 2: Run test to verify it fails**

Run: `bun test`
Expected: FAIL with "Cannot find module './preview'"

**Step 3: Write preview generator**

```typescript
// src/preview.ts
import type { Toolpath } from './toolpath'

export function generatePreviewSVG(toolpath: Toolpath, width: number, height: number): string {
  const { bounds, params } = toolpath
  const padding = 20

  // Calculate scale to fit preview
  const contentWidth = bounds.xMax - bounds.xMin
  const contentHeight = bounds.yMax - bounds.yMin
  const scaleX = (width - 2 * padding) / contentWidth
  const scaleY = (height - 2 * padding) / contentHeight
  const scale = Math.min(scaleX, scaleY)

  // Transform functions (flip Y axis for SVG coordinates)
  const tx = (x: number) => padding + (x - bounds.xMin) * scale
  const ty = (y: number) => height - padding - (y - bounds.yMin) * scale

  const lines: string[] = []

  lines.push(`<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">`)

  // Styles
  lines.push('<style>')
  lines.push('  .stock { fill: #f5f5dc; stroke: #8b7355; stroke-width: 2; }')
  lines.push('  .overhang { fill: none; stroke: #ccc; stroke-width: 1; stroke-dasharray: 4; }')
  lines.push('  .raster { stroke: #2196F3; stroke-width: 1; opacity: 0.7; }')
  lines.push('  .start { fill: #4CAF50; }')
  lines.push('</style>')

  // Overhang area (dashed rectangle)
  lines.push(`<rect class="overhang" x="${tx(bounds.xMin)}" y="${ty(bounds.yMax)}" width="${contentWidth * scale}" height="${contentHeight * scale}" />`)

  // Stock rectangle
  lines.push(`<rect class="stock" x="${tx(0)}" y="${ty(params.stockHeight)}" width="${params.stockWidth * scale}" height="${params.stockHeight * scale}" />`)

  // Raster lines (first pass only for preview)
  const firstPass = toolpath.passes[0]
  if (firstPass) {
    firstPass.lines.forEach(line => {
      lines.push(`<line class="raster" x1="${tx(line.xStart)}" y1="${ty(line.y)}" x2="${tx(line.xEnd)}" y2="${ty(line.y)}" />`)
    })

    // Start point indicator
    const startLine = firstPass.lines[0]
    if (startLine) {
      lines.push(`<circle class="start" cx="${tx(startLine.xStart)}" cy="${ty(startLine.y)}" r="5" />`)
    }
  }

  lines.push('</svg>')

  return lines.join('\n')
}
```

**Step 4: Run test to verify it passes**

Run: `bun test`
Expected: PASS

**Step 5: Commit**

```bash
git add .
git commit -m "feat: add SVG preview rendering"
```

---

### Task 7: UI Form and Layout

**Files:**
- Create: `src/ui.ts`
- Modify: `src/main.ts`
- Modify: `index.html`

**Step 1: Create CSS styles in index.html**

Replace `index.html`:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Surfacer</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 { margin: 0 0 20px; }
    .container {
      display: grid;
      grid-template-columns: 400px 1fr;
      gap: 30px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .form-section {
      background: white;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
    }
    .form-section h3 {
      margin: 0 0 10px;
      font-size: 14px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .form-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .form-row:last-child { margin-bottom: 0; }
    label {
      flex: 0 0 140px;
      font-size: 14px;
    }
    input[type="number"] {
      width: 100px;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    input[type="number"]:focus {
      outline: none;
      border-color: #2196F3;
    }
    .unit { margin-left: 8px; color: #666; font-size: 14px; }
    .radio-group {
      display: flex;
      gap: 15px;
    }
    .radio-group label {
      flex: none;
      display: flex;
      align-items: center;
      gap: 5px;
      cursor: pointer;
    }
    input[type="radio"], input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }
    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .conditional-field {
      margin-left: 24px;
      margin-top: 8px;
    }
    .hidden { display: none; }
    .preview-container {
      background: white;
      border-radius: 8px;
      padding: 20px;
    }
    #preview {
      width: 100%;
      aspect-ratio: 4/3;
      background: #fafafa;
      border: 1px solid #eee;
      border-radius: 4px;
    }
    #preview svg { width: 100%; height: 100%; }
    .generate-btn {
      display: block;
      width: 100%;
      padding: 15px;
      margin-top: 20px;
      background: #2196F3;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }
    .generate-btn:hover { background: #1976D2; }
    .generate-btn:active { background: #1565C0; }
  </style>
</head>
<body>
  <div id="app"></div>
  <script type="module" src="/src/main.ts"></script>
</body>
</html>
```

**Step 2: Create UI module**

```typescript
// src/ui.ts
import type { SurfacingParams } from './types'
import { DEFAULT_PARAMS } from './defaults'

export function createForm(onUpdate: (params: Partial<SurfacingParams>) => void): HTMLElement {
  const form = document.createElement('div')
  form.className = 'form-column'
  form.innerHTML = `
    <div class="form-section">
      <h3>Stock Dimensions</h3>
      <div class="form-row">
        <label for="stockWidth">Width</label>
        <input type="number" id="stockWidth" step="0.1" min="0.1" required>
        <span class="unit">in</span>
      </div>
      <div class="form-row">
        <label for="stockHeight">Height</label>
        <input type="number" id="stockHeight" step="0.1" min="0.1" required>
        <span class="unit">in</span>
      </div>
    </div>

    <div class="form-section">
      <h3>Tool Settings</h3>
      <div class="form-row">
        <label for="bitDiameter">Bit Diameter</label>
        <input type="number" id="bitDiameter" value="${DEFAULT_PARAMS.bitDiameter}" step="0.125" min="0.125">
        <span class="unit">in</span>
      </div>
      <div class="form-row">
        <label for="stepoverPercent">Stepover</label>
        <input type="number" id="stepoverPercent" value="${DEFAULT_PARAMS.stepoverPercent}" step="5" min="10" max="100">
        <span class="unit">%</span>
      </div>
      <div class="form-row">
        <label>Overhang</label>
        <div class="radio-group">
          <label><input type="radio" name="overhangMode" value="full" checked> Full</label>
          <label><input type="radio" name="overhangMode" value="custom"> Custom</label>
        </div>
      </div>
      <div class="form-row conditional-field hidden" id="customOverhangRow">
        <label for="customOverhang">Amount</label>
        <input type="number" id="customOverhang" value="0.5" step="0.125" min="0">
        <span class="unit">in</span>
      </div>
    </div>

    <div class="form-section">
      <h3>Toolpath</h3>
      <div class="form-row">
        <label>Direction</label>
        <div class="radio-group">
          <label><input type="radio" name="rasterDirection" value="x" checked> X-axis</label>
          <label><input type="radio" name="rasterDirection" value="y"> Y-axis</label>
        </div>
      </div>
      <div class="form-row checkbox-row">
        <input type="checkbox" id="skimPass">
        <label for="skimPass">Skim pass (Z=0 first)</label>
      </div>
      <div class="form-row">
        <label for="numPasses">Number of Passes</label>
        <input type="number" id="numPasses" value="${DEFAULT_PARAMS.numPasses}" step="1" min="1">
      </div>
      <div class="form-row">
        <label for="depthPerPass">Depth per Pass</label>
        <input type="number" id="depthPerPass" value="${DEFAULT_PARAMS.depthPerPass}" step="0.005" min="0.001">
        <span class="unit">in</span>
      </div>
      <div class="form-row checkbox-row">
        <input type="checkbox" id="pauseBetweenPasses">
        <label for="pauseBetweenPasses">Pause between passes</label>
      </div>
      <div class="form-row conditional-field hidden" id="pauseIntervalRow">
        <label for="pauseInterval">Every</label>
        <input type="number" id="pauseInterval" value="${DEFAULT_PARAMS.pauseInterval}" step="1" min="1">
        <span class="unit">pass(es)</span>
      </div>
    </div>

    <div class="form-section">
      <h3>Speeds & Feeds</h3>
      <div class="form-row">
        <label for="feedRate">Feed Rate</label>
        <input type="number" id="feedRate" value="${DEFAULT_PARAMS.feedRate}" step="5" min="1">
        <span class="unit">in/min</span>
      </div>
      <div class="form-row">
        <label for="plungeRate">Plunge Rate</label>
        <input type="number" id="plungeRate" value="${DEFAULT_PARAMS.plungeRate}" step="1" min="1">
        <span class="unit">in/min</span>
      </div>
      <div class="form-row">
        <label for="spindleRpm">Spindle RPM</label>
        <input type="number" id="spindleRpm" value="${DEFAULT_PARAMS.spindleRpm}" step="500" min="1000">
      </div>
      <div class="form-row">
        <label for="safeZ">Safe Z</label>
        <input type="number" id="safeZ" value="${DEFAULT_PARAMS.safeZ}" step="0.125" min="0.01">
        <span class="unit">in</span>
      </div>
    </div>
  `

  // Wire up event listeners
  const inputs = form.querySelectorAll('input')
  inputs.forEach(input => {
    input.addEventListener('input', () => onUpdate(getFormValues(form)))
    input.addEventListener('change', () => onUpdate(getFormValues(form)))
  })

  // Handle conditional fields
  const overhangRadios = form.querySelectorAll('input[name="overhangMode"]')
  const customOverhangRow = form.querySelector('#customOverhangRow')!
  overhangRadios.forEach(radio => {
    radio.addEventListener('change', (e) => {
      const target = e.target as HTMLInputElement
      customOverhangRow.classList.toggle('hidden', target.value !== 'custom')
    })
  })

  const pauseCheckbox = form.querySelector('#pauseBetweenPasses') as HTMLInputElement
  const pauseIntervalRow = form.querySelector('#pauseIntervalRow')!
  pauseCheckbox.addEventListener('change', () => {
    pauseIntervalRow.classList.toggle('hidden', !pauseCheckbox.checked)
  })

  return form
}

export function getFormValues(form: HTMLElement): Partial<SurfacingParams> {
  const getValue = (id: string): number => {
    const input = form.querySelector(`#${id}`) as HTMLInputElement
    return parseFloat(input.value) || 0
  }

  const getChecked = (id: string): boolean => {
    const input = form.querySelector(`#${id}`) as HTMLInputElement
    return input.checked
  }

  const getRadio = (name: string): string => {
    const input = form.querySelector(`input[name="${name}"]:checked`) as HTMLInputElement
    return input?.value || ''
  }

  return {
    stockWidth: getValue('stockWidth'),
    stockHeight: getValue('stockHeight'),
    bitDiameter: getValue('bitDiameter'),
    stepoverPercent: getValue('stepoverPercent'),
    overhangMode: getRadio('overhangMode') as 'full' | 'custom',
    customOverhang: getValue('customOverhang'),
    rasterDirection: getRadio('rasterDirection') as 'x' | 'y',
    skimPass: getChecked('skimPass'),
    numPasses: getValue('numPasses'),
    depthPerPass: getValue('depthPerPass'),
    pauseBetweenPasses: getChecked('pauseBetweenPasses'),
    pauseInterval: getValue('pauseInterval'),
    feedRate: getValue('feedRate'),
    plungeRate: getValue('plungeRate'),
    spindleRpm: getValue('spindleRpm'),
    safeZ: getValue('safeZ'),
  }
}

export function isFormValid(params: Partial<SurfacingParams>): boolean {
  return !!(params.stockWidth && params.stockWidth > 0 &&
            params.stockHeight && params.stockHeight > 0)
}
```

**Step 3: Update main.ts**

```typescript
// src/main.ts
import { createForm, getFormValues, isFormValid } from './ui'
import { calculateToolpath } from './toolpath'
import { generateGCode } from './gcode'
import { generatePreviewSVG } from './preview'
import { mergeWithDefaults } from './defaults'
import type { SurfacingParams } from './types'

function init() {
  const app = document.querySelector<HTMLDivElement>('#app')!

  app.innerHTML = `
    <h1>Surfacer</h1>
    <div class="container">
      <div id="form-container"></div>
      <div class="preview-container">
        <div id="preview"></div>
        <button class="generate-btn" id="generateBtn" disabled>Generate GCode</button>
      </div>
    </div>
  `

  const formContainer = app.querySelector('#form-container')!
  const previewContainer = app.querySelector('#preview')!
  const generateBtn = app.querySelector('#generateBtn') as HTMLButtonElement

  let currentParams: Partial<SurfacingParams> = {}

  function updatePreview() {
    if (!isFormValid(currentParams)) {
      previewContainer.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">Enter stock dimensions to see preview</p>'
      generateBtn.disabled = true
      return
    }

    const params = mergeWithDefaults(currentParams as { stockWidth: number; stockHeight: number } & Partial<SurfacingParams>)
    const toolpath = calculateToolpath(params)
    const rect = previewContainer.getBoundingClientRect()
    const svg = generatePreviewSVG(toolpath, rect.width || 500, rect.height || 375)
    previewContainer.innerHTML = svg
    generateBtn.disabled = false
  }

  const form = createForm((params) => {
    currentParams = params
    updatePreview()
  })
  formContainer.appendChild(form)

  generateBtn.addEventListener('click', () => {
    if (!isFormValid(currentParams)) return

    const params = mergeWithDefaults(currentParams as { stockWidth: number; stockHeight: number } & Partial<SurfacingParams>)
    const toolpath = calculateToolpath(params)
    const gcode = generateGCode(toolpath)

    // Download
    const blob = new Blob([gcode], { type: 'text/plain' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `surfacing-${params.stockWidth}x${params.stockHeight}.gcode`
    a.click()
    URL.revokeObjectURL(url)
  })

  // Initial preview
  updatePreview()
}

init()
```

**Step 4: Run dev server and verify UI**

Run: `bun run dev`
Expected: Opens browser with form on left, preview on right

**Step 5: Commit**

```bash
git add .
git commit -m "feat: add UI form and layout"
```

---

### Task 8: Y-Axis Raster Support

**Files:**
- Modify: `src/toolpath.ts`
- Modify: `src/toolpath.test.ts`

**Step 1: Write test for Y-axis raster**

Add to `src/toolpath.test.ts`:

```typescript
describe('Y-axis raster', () => {
  test('generates lines along Y axis when direction is y', () => {
    const params = mergeWithDefaults({
      stockWidth: 10,
      stockHeight: 5,
      rasterDirection: 'y',
      bitDiameter: 1,
      stepoverPercent: 50,
    })

    const toolpath = calculateToolpath(params)
    const firstLine = toolpath.passes[0].lines[0]

    // Y-axis raster means lines run along Y, stepping over in X
    // So yStart and yEnd should differ, xStart should equal the line's x position
    expect(firstLine.yStart).toBeDefined()
    expect(firstLine.yEnd).toBeDefined()
  })
})
```

**Step 2: Run test to verify it fails**

Run: `bun test`
Expected: FAIL (yStart/yEnd not defined)

**Step 3: Update toolpath types and calculation**

Update `src/toolpath.ts`:

```typescript
// src/toolpath.ts
import type { SurfacingParams } from './types'

export interface RasterLine {
  // For X-axis raster: y is fixed, x varies
  // For Y-axis raster: x is fixed, y varies
  x?: number
  y?: number
  xStart?: number
  xEnd?: number
  yStart?: number
  yEnd?: number
  direction: 'positive' | 'negative'
}

export interface ZPass {
  z: number
  lines: RasterLine[]
  pauseAfter: boolean
}

export interface Toolpath {
  passes: ZPass[]
  bounds: {
    xMin: number
    xMax: number
    yMin: number
    yMax: number
  }
  params: SurfacingParams
}

export function calculateToolpath(params: SurfacingParams): Toolpath {
  const overhang = params.overhangMode === 'full'
    ? params.bitDiameter
    : params.customOverhang

  const stepover = params.bitDiameter * (params.stepoverPercent / 100)

  // Calculate bounds with overhang
  const xMin = -overhang
  const xMax = params.stockWidth + overhang
  const yMin = -overhang
  const yMax = params.stockHeight + overhang

  // Generate raster lines based on direction
  let linePositions: number[] = []

  if (params.rasterDirection === 'x') {
    // Lines run along X, step over in Y
    let y = yMin
    while (y <= yMax) {
      linePositions.push(y)
      y += stepover
    }
    if (linePositions[linePositions.length - 1] < yMax) {
      linePositions.push(yMax)
    }
  } else {
    // Lines run along Y, step over in X
    let x = xMin
    while (x <= xMax) {
      linePositions.push(x)
      x += stepover
    }
    if (linePositions[linePositions.length - 1] < xMax) {
      linePositions.push(xMax)
    }
  }

  // Generate Z passes
  const passes: ZPass[] = []
  const totalPasses = params.numPasses + (params.skimPass ? 1 : 0)

  for (let i = 0; i < totalPasses; i++) {
    const isSkimPass = params.skimPass && i === 0
    const adjustedIndex = params.skimPass ? i : i + 1
    const z = isSkimPass ? 0 : -(adjustedIndex * params.depthPerPass)

    const lines: RasterLine[] = linePositions.map((pos, lineIndex) => {
      const isEven = lineIndex % 2 === 0

      if (params.rasterDirection === 'x') {
        return {
          y: pos,
          xStart: isEven ? xMin : xMax,
          xEnd: isEven ? xMax : xMin,
          direction: (isEven ? 'positive' : 'negative') as const,
        }
      } else {
        return {
          x: pos,
          yStart: isEven ? yMin : yMax,
          yEnd: isEven ? yMax : yMin,
          direction: (isEven ? 'positive' : 'negative') as const,
        }
      }
    })

    const shouldPause = params.pauseBetweenPasses &&
      (i + 1) % params.pauseInterval === 0 &&
      i < totalPasses - 1

    passes.push({ z, lines, pauseAfter: shouldPause })
  }

  return {
    passes,
    bounds: { xMin, xMax, yMin, yMax },
    params,
  }
}
```

**Step 4: Update gcode.ts to handle Y-axis raster**

Update the `generatePass` function in `src/gcode.ts`:

```typescript
function generatePass(pass: ZPass, safeZ: number, feedRate: number, plungeRate: number, direction: 'x' | 'y'): string[] {
  const lines: string[] = []

  pass.lines.forEach((line, lineIndex) => {
    if (direction === 'x') {
      // X-axis raster
      if (lineIndex === 0) {
        lines.push(`G0 Y${fmt(line.y!)}`)
        lines.push(`G0 X${fmt(line.xStart!)}`)
        lines.push(`G1 Z${fmt(pass.z)} F${plungeRate} ; Plunge`)
      } else {
        lines.push(`G0 Z${fmt(safeZ)} ; Retract`)
        lines.push(`G0 Y${fmt(line.y!)} ; Stepover`)
        lines.push(`G0 X${fmt(line.xStart!)}`)
        lines.push(`G1 Z${fmt(pass.z)} F${plungeRate} ; Plunge`)
      }
      lines.push(`G1 X${fmt(line.xEnd!)} F${feedRate} ; Cut`)
    } else {
      // Y-axis raster
      if (lineIndex === 0) {
        lines.push(`G0 X${fmt(line.x!)}`)
        lines.push(`G0 Y${fmt(line.yStart!)}`)
        lines.push(`G1 Z${fmt(pass.z)} F${plungeRate} ; Plunge`)
      } else {
        lines.push(`G0 Z${fmt(safeZ)} ; Retract`)
        lines.push(`G0 X${fmt(line.x!)} ; Stepover`)
        lines.push(`G0 Y${fmt(line.yStart!)}`)
        lines.push(`G1 Z${fmt(pass.z)} F${plungeRate} ; Plunge`)
      }
      lines.push(`G1 Y${fmt(line.yEnd!)} F${feedRate} ; Cut`)
    }
  })

  lines.push(`G0 Z${fmt(safeZ)} ; Retract after pass`)

  return lines
}
```

Also update the call to `generatePass` in `generateGCode`:

```typescript
lines.push(...generatePass(pass, params.safeZ, params.feedRate, params.plungeRate, params.rasterDirection))
```

**Step 5: Update preview.ts for Y-axis raster**

Update `src/preview.ts`:

```typescript
// Raster lines (first pass only for preview)
const firstPass = toolpath.passes[0]
if (firstPass) {
  firstPass.lines.forEach(line => {
    if (params.rasterDirection === 'x') {
      lines.push(`<line class="raster" x1="${tx(line.xStart!)}" y1="${ty(line.y!)}" x2="${tx(line.xEnd!)}" y2="${ty(line.y!)}" />`)
    } else {
      lines.push(`<line class="raster" x1="${tx(line.x!)}" y1="${ty(line.yStart!)}" x2="${tx(line.x!)}" y2="${ty(line.yEnd!)}" />`)
    }
  })

  // Start point indicator
  const startLine = firstPass.lines[0]
  if (startLine) {
    const startX = params.rasterDirection === 'x' ? startLine.xStart! : startLine.x!
    const startY = params.rasterDirection === 'x' ? startLine.y! : startLine.yStart!
    lines.push(`<circle class="start" cx="${tx(startX)}" cy="${ty(startY)}" r="5" />`)
  }
}
```

**Step 6: Run tests to verify**

Run: `bun test`
Expected: PASS

**Step 7: Commit**

```bash
git add .
git commit -m "feat: add Y-axis raster support"
```

---

### Task 9: Input Validation

**Files:**
- Modify: `src/ui.ts`

**Step 1: Add validation feedback to form**

Add to CSS in `index.html`:

```css
input:invalid {
  border-color: #f44336;
}
.validation-error {
  color: #f44336;
  font-size: 12px;
  margin-top: 4px;
}
```

**Step 2: Update isFormValid with detailed validation**

Add to `src/ui.ts`:

```typescript
export function validateParams(params: Partial<SurfacingParams>): string[] {
  const errors: string[] = []

  if (!params.stockWidth || params.stockWidth <= 0) {
    errors.push('Stock width must be greater than 0')
  }
  if (!params.stockHeight || params.stockHeight <= 0) {
    errors.push('Stock height must be greater than 0')
  }
  if (params.bitDiameter && params.bitDiameter <= 0) {
    errors.push('Bit diameter must be greater than 0')
  }
  if (params.stepoverPercent && (params.stepoverPercent < 10 || params.stepoverPercent > 100)) {
    errors.push('Stepover must be between 10% and 100%')
  }
  if (params.numPasses && params.numPasses < 1) {
    errors.push('Number of passes must be at least 1')
  }
  if (params.depthPerPass && params.depthPerPass <= 0) {
    errors.push('Depth per pass must be greater than 0')
  }

  return errors
}
```

**Step 3: Run dev and test validation**

Run: `bun run dev`
Expected: Form shows validation states, Generate button disabled when invalid

**Step 4: Commit**

```bash
git add .
git commit -m "feat: add input validation"
```

---

### Task 10: Final Build and Test

**Files:**
- None (verification only)

**Step 1: Run all tests**

Run: `bun test`
Expected: All tests pass

**Step 2: Build production bundle**

Run: `bun run build`
Expected: Creates `dist/index.html` as single file

**Step 3: Verify single file works**

Run: Open `dist/index.html` directly in browser (double-click or `open dist/index.html`)
Expected: App works fully offline

**Step 4: Test GCode output**

1. Enter stock dimensions (e.g., 12x12)
2. Click Generate GCode
3. Open downloaded file
4. Verify:
   - Preamble present (G90, G20, M3)
   - Z depths correct
   - M0 appears if pause enabled
   - Postamble present (M5, M30)

**Step 5: Final commit**

```bash
git add .
git commit -m "chore: verify build and tests pass"
```

---

## Verification Checklist

- [ ] `bun test` passes all tests
- [ ] `bun run build` creates single HTML file
- [ ] App opens from dist/index.html without server
- [ ] Form inputs update live preview
- [ ] Generate button downloads .gcode file
- [ ] GCode has correct preamble/postamble
- [ ] Skim pass adds Z=0 first pass
- [ ] Pause intervals insert M0 correctly
- [ ] Y-axis raster works
- [ ] Custom overhang works
